import{_ as e,o as t,c as l,R as a}from"./chunks/framework.T1JPdAmG.js";const o="/myBlog/assets/zoom-in-crop-mark.WC_lnFVZ.webp",s="/myBlog/assets/zIndexcrop-mark.Z_5Pes9D.webp",m=JSON.parse('{"title":"简述Css3","description":"","frontmatter":{},"headers":[],"relativePath":"markdown-Css3.md","filePath":"markdown-Css3.md"}'),i={name:"markdown-Css3.md"},n=a(`<h1 id="简述css3" tabindex="-1">简述Css3 <a class="header-anchor" href="#简述css3" aria-label="Permalink to &quot;简述Css3&quot;">​</a></h1><p>CSS是层叠样式表（Cascading Style Sheets）的缩写，是一种用来描述网页样式和布局的语言，可以控制网页的字体、颜色、对齐方式、边框、背景等外观相关属性。它可以使网页实现更加优美和动态的效果。</p><p>在网页开发中，HTML负责网页结构和内容，而CSS则负责网页的展示效果。CSS的作用可以说是为HTML文档添加样式和布局，使之呈现更加美观、易读、易用的页面。通过CSS，可以实现网页的响应式设计，使网页在不同设备屏幕上都有较好的展示效果，增强了用户的交互体验。同时，CSS还可以提高网页的性能，通过分离样式和内容，减小页面文件的大小，使得网页的加载速度更快。</p><h2 id="css-选择器及其优先级" tabindex="-1">CSS 选择器及其优先级 <a class="header-anchor" href="#css-选择器及其优先级" aria-label="Permalink to &quot;CSS 选择器及其优先级&quot;">​</a></h2><table><thead><tr><th style="text-align:center;">选择器</th><th style="text-align:center;">格式</th><th style="text-align:center;">优先级权重</th></tr></thead><tbody><tr><td style="text-align:center;">!important</td><td style="text-align:center;"></td><td style="text-align:center;">10000</td></tr><tr><td style="text-align:center;">内联样式</td><td style="text-align:center;">#id</td><td style="text-align:center;">1000</td></tr><tr><td style="text-align:center;">id 选择器</td><td style="text-align:center;">.classname</td><td style="text-align:center;">100</td></tr><tr><td style="text-align:center;">类选择器</td><td style="text-align:center;">a[ref=“eee”]</td><td style="text-align:center;">10</td></tr><tr><td style="text-align:center;">属性选择器</td><td style="text-align:center;">li:last-child</td><td style="text-align:center;">10</td></tr><tr><td style="text-align:center;">伪类选择器</td><td style="text-align:center;">div</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">伪元素选择器</td><td style="text-align:center;">li::after</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">相邻兄弟选择器</td><td style="text-align:center;">h1+p</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">子选择器</td><td style="text-align:center;">ul&gt;li</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">后代选择器</td><td style="text-align:center;">li a</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">后代选择器</td><td style="text-align:center;">*</td><td style="text-align:center;">0</td></tr></tbody></table><p>注意事项：</p><ul><li>!important 声明的样式的优先级最高；<br></li><li>如果优先级相同，则最后出现的样式生效；<br></li><li>继承得到的样式的优先级最低；<br></li><li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，它们的权值都为 0 ；<br></li><li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。<br></li></ul><h2 id="对盒模型的理解" tabindex="-1">对盒模型的理解 <a class="header-anchor" href="#对盒模型的理解" aria-label="Permalink to &quot;对盒模型的理解&quot;">​</a></h2><p>CSS3 中的盒模型有以下两种：<code>标准盒模型</code>、<code>IE 盒模型</code><br></p><p><code>盒模型</code>是由四个部分组成的，分别是 <code>margin</code>、<code>border</code>、<code>padding</code> 和 <code>content。</code><br></p><p><code>标准盒模型</code>和 IE 盒模型的区别在于设置 <code>width</code> 和 <code>height</code> 时，所对应的范围不同：<br> 标准盒模型的 width 和 height 属性的范围只包含了 <code>content</code>，<br> IE 盒模型的 width 和 height 属性的范围包含了 <code>border</code>、<code>padding</code> 和 <code>content</code>。<br></p><p>可以通过修改元素的 box-sizing 属性来改变元素的盒模型：<br> box-sizing: <code>content-box</code>表示标准盒模型（默认值）<br> box-sizing: <code>border-box</code>表示 IE 盒模型（怪异盒模型）<br></p><h2 id="css-中可继承与不可继承属性有哪些" tabindex="-1">CSS 中可继承与不可继承属性有哪些 <a class="header-anchor" href="#css-中可继承与不可继承属性有哪些" aria-label="Permalink to &quot;CSS 中可继承与不可继承属性有哪些&quot;">​</a></h2><p>可继承：</p><p><code>字体系列</code> font-family font-weight font-size</p><p><code>文本系列</code> color text-align line-height</p><p><code>可见系列</code> 如 visibility</p><div class="info custom-block"><p class="custom-block-title">由于属性太多，这里只列举常见的可继承的属性</p></div><p>不可继承：</p><p><code>display属性</code></p><p><code>文本属性</code>：vertical-align、text-decoration</p><p><code>盒子模型的属性</code>: width、height、padding、margin、boder等</p><p><code>背景属性</code>：background-image、background-color、background-position等</p><p><code>定位属性</code>：float、clear、position、transform等</p><p><code>生成内容属性</code>: content、counter-reset、counter-increment</p><p><code>轮廓样式属性</code>: outline-style、outline-width、outline-color、outline</p><div class="info custom-block"><p class="custom-block-title">由于属性太多，这里只列举常见的不可继承的属性</p></div><h2 id="css-优化和提高性能的方法有哪些" tabindex="-1">CSS 优化和提高性能的方法有哪些？ <a class="header-anchor" href="#css-优化和提高性能的方法有哪些" aria-label="Permalink to &quot;CSS 优化和提高性能的方法有哪些？&quot;">​</a></h2><h4 id="加载性能" tabindex="-1">加载性能： <a class="header-anchor" href="#加载性能" aria-label="Permalink to &quot;加载性能：&quot;">​</a></h4><ul><li>css 压缩, 减小文件体积。</li><li>css 单一样式 margin-bottom:bottom； margin-left:left；比 margin:top 0 bottom 0；执行效率高。</li><li>减少使用 @import，建议使用 link，因为 link 在页面加载时一起加载，import 是页面加载完成之后再加载。</li></ul><h4 id="选择器性能" tabindex="-1">选择器性能： <a class="header-anchor" href="#选择器性能" aria-label="Permalink to &quot;选择器性能：&quot;">​</a></h4><ul><li><code>关键</code>选择器, 减少层级, 最高不超过3层</li><li>尽量使用<code>class</code>, 避免使用html标签选择</li><li>少使用<code>后代</code>选择器, 后代选择器<code>开销高</code></li><li>避免对<code>可继承</code>的属性<code>重复</code>定义</li><li>避免使用<code>通配</code>规则, 只对需要的元素进行处理</li></ul><h4 id="渲染性能" tabindex="-1">渲染性能： <a class="header-anchor" href="#渲染性能" aria-label="Permalink to &quot;渲染性能：&quot;">​</a></h4><ul><li>慎重使用高性能属性：<code>浮动</code>、<code>定位</code>。</li><li>尽量减少页面<code>重排</code>、<code>重绘</code>。</li><li>属性值为 0 时，不加单位。</li><li>属性值为浮动小数 0.**，可以<code>省略</code>小数点之前的 0。</li><li>不使用<code>@import</code>前缀，它会影响 css 的<code>加载速度</code>。</li></ul><h4 id="可维护性" tabindex="-1">可维护性： <a class="header-anchor" href="#可维护性" aria-label="Permalink to &quot;可维护性：&quot;">​</a></h4><ul><li>抽离 <code>css</code>, 提高<code>可复用性</code>。</li><li>样式与内容<code>分离</code>, 提高<code>可维护性</code>。</li></ul><h2 id="css-预处理器-后处理器是什么-为什么要使用它们" tabindex="-1">CSS 预处理器/后处理器是什么？为什么要使用它们？ <a class="header-anchor" href="#css-预处理器-后处理器是什么-为什么要使用它们" aria-label="Permalink to &quot;CSS 预处理器/后处理器是什么？为什么要使用它们？&quot;">​</a></h2><p>预处理器， 如：<code>less</code>，<code>sass</code>，用来预编译 sass或者less，增加了 css 代码的<code>复用性</code>。层级，循环， 变量，循环等功能对UI组件<code>更易开发</code>与<code>维护</code>。</p><p>后处理器， 如： <code>PostCSS</code>，通常是在完成的样式表中根据 CSS 规范处理 CSS<code>有效</code>。最常做的是添加浏览器私有<code>前缀</code>，解决跨浏览器<code>兼容性</code>的问题。</p><p>使用原因：</p><ol><li>结构清晰， 便于<code>扩展</code></li><li>可以很方便的<code>屏蔽</code>浏览器私有语法的差异</li><li>完美的<code>兼容</code>了 CSS 代码，可以应用到老项目中</li><li>可以轻松实现<code>多重继承</code></li></ol><h2 id="link-和-import-的区别" tabindex="-1">link 和 @import 的区别 <a class="header-anchor" href="#link-和-import-的区别" aria-label="Permalink to &quot;link 和 @import 的区别&quot;">​</a></h2><p>两者都是外部引用 CSS 的方式，它们的区别如下：<br></p><p><code>link</code> 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； <code>@import</code> 只能加载 CSS。<br><code>link</code> 引用 CSS 时，在页面载入时同时加载； <code>@import</code> 需要页面网页完全载入以后加载。<br><code>link</code> 是 XHTML 标签，无兼容问题； <code>@import</code> 是在 CSS2.1 提出的，低版本的浏览器不支持。<br><code>link</code> 支持使用 Javascript 控制 DOM 去改变样式； <code>@import</code> 不支持。<br></p><h2 id="transition-和-animation-的区别" tabindex="-1">transition 和 animation 的区别 <a class="header-anchor" href="#transition-和-animation-的区别" aria-label="Permalink to &quot;transition 和 animation 的区别&quot;">​</a></h2><p><code>transition</code> 是<code>过度属性</code>，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于 flash 的补间动画，设置一个开始关键帧，一个结束关键帧。<br></p><p><code>animation</code> 是<code>动画属性</code>，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于 flash 的补间动画，但是它可以设置多个关键帧（用@keyframe 定义）完成动画。<br></p><h2 id="display-none-与-visibility-hidden-的区别" tabindex="-1">display:none 与 visibility:hidden 的区别 <a class="header-anchor" href="#display-none-与-visibility-hidden-的区别" aria-label="Permalink to &quot;display:none 与 visibility:hidden 的区别&quot;">​</a></h2><p>这两个属性都是让元素隐藏，不可见。两者区别如下：</p><ol><li>在渲染树中</li></ol><ul><li><code>display:none</code> 不渲染元素</li><li><code>sibility:hidden</code>渲染元素，只是不可见</li></ul><ol start="2"><li>是否是继承属性</li></ol><ul><li><code>display:none</code> 是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li><code>visibility:hidden</code> 是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；</li></ul><ol start="3"><li>重排与重绘</li></ol><ul><li><code>display:none</code> 修改此属性，会导致整个文档重排</li><li><code>visibility:hidden</code> 修改此属性，只会导致当前元素重绘</li></ul><h2 id="为什么有时候用-translate-来改变位置而不是定位" tabindex="-1">为什么有时候⽤ translate 来改变位置而不是定位？ <a class="header-anchor" href="#为什么有时候用-translate-来改变位置而不是定位" aria-label="Permalink to &quot;为什么有时候⽤ translate 来改变位置而不是定位？&quot;">​</a></h2><p><code>translate</code> 不会触发浏览器重排和重绘,只会触发复合, 利用GPU效率高<br><code>绝对定位</code>会导致重排, 进而触发重绘, 利用CPU效率低</p><h2 id="单行、多行文本溢出隐藏" tabindex="-1">单行、多行文本溢出隐藏 <a class="header-anchor" href="#单行、多行文本溢出隐藏" aria-label="Permalink to &quot;单行、多行文本溢出隐藏&quot;">​</a></h2><h4 id="单行文本溢出" tabindex="-1">单行文本溢出 <a class="header-anchor" href="#单行文本溢出" aria-label="Permalink to &quot;单行文本溢出&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">overflow: hidden;            // 溢出隐藏</span></span>
<span class="line"><span style="color:#e1e4e8;">text-overflow: ellipsis;      // 溢出用省略号显示</span></span>
<span class="line"><span style="color:#e1e4e8;">white-space: nowrap;         // 规定段落中的文本不进行换行</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">overflow: hidden;            // 溢出隐藏</span></span>
<span class="line"><span style="color:#24292e;">text-overflow: ellipsis;      // 溢出用省略号显示</span></span>
<span class="line"><span style="color:#24292e;">white-space: nowrap;         // 规定段落中的文本不进行换行</span></span></code></pre></div><h4 id="多行文本溢出" tabindex="-1">多行文本溢出 <a class="header-anchor" href="#多行文本溢出" aria-label="Permalink to &quot;多行文本溢出&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">overflow: hidden;            // 溢出隐藏</span></span>
<span class="line"><span style="color:#e1e4e8;">text-overflow: ellipsis;     // 溢出用省略号显示</span></span>
<span class="line"><span style="color:#e1e4e8;">display: -webkit-box;         // 作为弹性伸缩盒子模型显示。</span></span>
<span class="line"><span style="color:#e1e4e8;">-webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span></span>
<span class="line"><span style="color:#e1e4e8;">-webkit-line-clamp: 3;        // 显示的行数</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">overflow: hidden;            // 溢出隐藏</span></span>
<span class="line"><span style="color:#24292e;">text-overflow: ellipsis;     // 溢出用省略号显示</span></span>
<span class="line"><span style="color:#24292e;">display: -webkit-box;         // 作为弹性伸缩盒子模型显示。</span></span>
<span class="line"><span style="color:#24292e;">-webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span></span>
<span class="line"><span style="color:#24292e;">-webkit-line-clamp: 3;        // 显示的行数</span></span></code></pre></div><h4 id="对媒体查询的理解" tabindex="-1">对媒体查询的理解？ <a class="header-anchor" href="#对媒体查询的理解" aria-label="Permalink to &quot;对媒体查询的理解？&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;!-- link元素中的CSS媒体查询 --&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;!-- 样式表中的CSS媒体查询 --&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;style&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">@media (max-width: 600px) {</span></span>
<span class="line"><span style="color:#e1e4e8;">  .facet_sidebar {</span></span>
<span class="line"><span style="color:#e1e4e8;">    display: none;</span></span>
<span class="line"><span style="color:#e1e4e8;">  }</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/style&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;!-- link元素中的CSS媒体查询 --&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;!-- 样式表中的CSS媒体查询 --&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;style&gt;</span></span>
<span class="line"><span style="color:#24292e;">@media (max-width: 600px) {</span></span>
<span class="line"><span style="color:#24292e;">  .facet_sidebar {</span></span>
<span class="line"><span style="color:#24292e;">    display: none;</span></span>
<span class="line"><span style="color:#24292e;">  }</span></span>
<span class="line"><span style="color:#24292e;">}</span></span>
<span class="line"><span style="color:#24292e;">&lt;/style&gt;</span></span></code></pre></div><p>简单来说，@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面。</p><h2 id="对-css-工程化的理解" tabindex="-1">对 CSS 工程化的理解 <a class="header-anchor" href="#对-css-工程化的理解" aria-label="Permalink to &quot;对 CSS 工程化的理解&quot;">​</a></h2><p>CSS 工程化是为了解决以下问题：<br></p><p>宏观设计： <code>CSS</code> 代码如何组织、如何拆分、模块结构怎样设计？<br> 编码优化： 怎样写出更好的 CSS ？<br> 构建： 如何处理我的 CSS，才能让它的<code>打包</code>结果最优？<br> 可维护性： 容易变更, 容易接手</p><p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：<br> 预处理器： Less、 Sass 等；<br> 后处理器： PostCSS<br> Webpack loader 等 。</p><p>如何用 Webpack 实现对 CSS 的处理：<br> css-loader： 导入 CSS 模块，对 CSS 代码进行编译处理；<br> style-loader： 创建 style 标签，把 CSS 内容写入标签。<br></p><p>在实际使用中，<code>css-loader 的执行顺序一定要安排在 style-loader 的前面</code>。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错</p><h2 id="如何判断元素是否到达可视区域" tabindex="-1">如何判断元素是否到达可视区域 <a class="header-anchor" href="#如何判断元素是否到达可视区域" aria-label="Permalink to &quot;如何判断元素是否到达可视区域&quot;">​</a></h2><h4 id="以图片显示为例" tabindex="-1">以图片显示为例： <a class="header-anchor" href="#以图片显示为例" aria-label="Permalink to &quot;以图片显示为例：&quot;">​</a></h4><ul><li>window.innerHeight是浏览器可视区的高度；</li><li>document.body.scrollTop || document.documentElement.scrollTop是浏览器滚动的过的距离；</li><li>imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）；</li><li>内容达到显示区域的：img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</li></ul><p><img src="`+o+`" alt="H5 图片"></p><h2 id="z-index-属性在什么情况下会失效" tabindex="-1">z-index 属性在什么情况下会失效 <a class="header-anchor" href="#z-index-属性在什么情况下会失效" aria-label="Permalink to &quot;z-index 属性在什么情况下会失效&quot;">​</a></h2><p>通常 <code>z-index</code> 的使用是在有两个<code>重叠</code>的标签，z-index 值越大就越是在上层。z-index 元素的 <code>position</code> 属性需要是 <code>relative</code>，<code>absolute</code> 或是 <code>fixed</code>。</p><p>z-index 属性在下列情况下会失效：</p><ul><li>父元素 position 为 <code>relative</code> 时，子元素的 z-index 失效。解决：父元素 position 改为 absolute 或 static；</li><li>元素没有设置 position 属性为非 static 属性。解决：设置该元素的 position 属性为 relative，absolute 或是 fixed；</li><li>元素在设置 z-index 的同时还设置了 <code>float</code> 浮动。解决：去除 float，改为 <code>display：inline-block</code>；</li></ul><h2 id="css3-中的-transform-有哪些属性" tabindex="-1">CSS3 中的 transform 有哪些属性 <a class="header-anchor" href="#css3-中的-transform-有哪些属性" aria-label="Permalink to &quot;CSS3 中的 transform 有哪些属性&quot;">​</a></h2><ul><li>translate 位移</li><li>rotate 旋转</li><li>scale 缩放</li><li>skew 斜切</li></ul><h2 id="常见的-css-布局单位" tabindex="-1">常见的 CSS 布局单位 <a class="header-anchor" href="#常见的-css-布局单位" aria-label="Permalink to &quot;常见的 CSS 布局单位&quot;">​</a></h2><p>像素px <code>基本</code>布局单位<br></p><p>百分比% ，相对于<code>父元素</code>的<code>百分比</code>，从而实现响应式的效果。<br></p><p>em 相对于父元素的文本的<code>倍数</code>。如果父元素未设置 <code>font-size</code>，则相对于浏览器的<code>默认</code>字体尺寸(默认 16px)。<br></p><p>rem 相对于根元素 <code>font-size</code> 的倍数。作用：利用 rem 可以实现简单的<code>响应式</code>布局，可以利用 html 元素中字体的大小与屏幕间的比值来设置 font-size 的值，以此实现当屏幕分辨率变化时让元素也随之变化。<br></p><p>vw： 相对于视窗的宽度，视窗宽度是 100vw；<br></p><p>vh： 相对于视窗的高度，视窗高度是 100vh；<br></p><p>vmin： vw 和 vh 中的较小值；<br></p><p>vmax： vw 和 vh 中的较大值；<br></p><p><code>vw</code> 和百分比的区别是: <code>vw</code> 相对于视窗, <code>%</code> 相对于父元素</p><h2 id="px、em、rem-的区别及使用场景" tabindex="-1">px、em、rem 的区别及使用场景 <a class="header-anchor" href="#px、em、rem-的区别及使用场景" aria-label="Permalink to &quot;px、em、rem 的区别及使用场景&quot;">​</a></h2><ul><li><code>px</code> 是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li><code>em</code> 和 <code>rem</code> 相对于 px 更具有灵活性，他们是<code>相对</code>长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em 是相对于其<code>父元素</code>来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而 rem 是相对于<code>根元素</code>，这样就意味着，只需要在根元素确定一个参考值。</li></ul><h4 id="使用场景" tabindex="-1">使用场景： <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景：&quot;">​</a></h4><ul><li>对于只需要适配<code>少部分</code>移动设备，且分辨率对页面影响不大的，使用 <code>px</code> 即可 。</li><li>对于需要适配<code>各种</code>移动设备，使用 <code>rem</code>，例如需要适配 iPhone 和 iPad 等分辨率差别比较挺大的设备。</li></ul><h2 id="如何根据设计稿进行移动端适配" tabindex="-1">如何根据设计稿进行移动端适配？ <a class="header-anchor" href="#如何根据设计稿进行移动端适配" aria-label="Permalink to &quot;如何根据设计稿进行移动端适配？&quot;">​</a></h2><p>移动端适配主要有<code>两个</code>维度：</p><p>适配不同像素密度，针对不同的<code>像素密度</code>，使用 CSS <code>媒体查询</code>，选择不同精度的图片，以保证图片不会<code>失真</code>；</p><p>适配不同屏幕大小，由于不同的屏幕有着不同的<code>逻辑像素</code>大小，所以如果直接使用 <code>px</code> 单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会<code>失真</code>。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</p><p>为了能让页面的尺寸自适应，可以使用 <code>rem</code>，<code>em</code>，<code>vw</code>，<code>vh</code> 等相对单位。</p><h2 id="响应式设计的概念及基本原理" tabindex="-1">响应式设计的概念及基本原理 <a class="header-anchor" href="#响应式设计的概念及基本原理" aria-label="Permalink to &quot;响应式设计的概念及基本原理&quot;">​</a></h2><p><code>响应式网站</code>是指一个网站能够<code>兼容多个终端</code>。</p><p>关于原理： 基本原理是通过媒体查询（@media）查询检测不同的设备屏幕尺寸做处理。</p><p>关于兼容： 页面头部必须有 <code>meta</code> 声明的 <code>viewport</code>。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot; /&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot; /&gt;</span></span></code></pre></div><h2 id="对-bfc-的理解-如何创建-bfc" tabindex="-1">对 BFC 的理解，如何创建 BFC <a class="header-anchor" href="#对-bfc-的理解-如何创建-bfc" aria-label="Permalink to &quot;对 BFC 的理解，如何创建 BFC&quot;">​</a></h2><p>先来看两个相关的概念：</p><ul><li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个 Box 就是我们所说的盒模型。</li><li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li></ul><p>块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视化 CSS 渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p>通俗来讲：BFC 是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响。</p><h4 id="创建-bfc-的条件" tabindex="-1">创建 BFC 的条件： <a class="header-anchor" href="#创建-bfc-的条件" aria-label="Permalink to &quot;创建 BFC 的条件：&quot;">​</a></h4><ul><li>根元素：body；</li><li>元素设置浮动：float 除 none 以外的值；</li><li>元素设置绝对定位：position (absolute、fixed)；</li><li>display 值为：inline-block、table-cell、table-caption、flex 等；</li><li>overflow 值为：hidden、auto、scroll；</li></ul><h4 id="bfc-的特点" tabindex="-1">BFC 的特点： <a class="header-anchor" href="#bfc-的特点" aria-label="Permalink to &quot;BFC 的特点：&quot;">​</a></h4><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在 BFC 中上下相邻的两个容器的 margin 会重叠</li><li>计算 BFC 的高度时，需要计算浮动元素的高度</li><li>BFC 区域不会与浮动的容器发生重叠</li><li>BFC 是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左 margin 值和容器的左 border 相接触</li></ul><h4 id="bfc-的作用" tabindex="-1">BFC 的作用： <a class="header-anchor" href="#bfc-的作用" aria-label="Permalink to &quot;BFC 的作用：&quot;">​</a></h4><ul><li>解决 margin 的重叠问题：由于 BFC 是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个 BFC，就解决了 margin 重叠的问题。</li><li>解决高度塌陷的问题：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为 0。解决这个问题，只需要把父元素变成一个 BFC。常用的办法是给父元素设置overflow:hidden。</li><li>创建自适应两栏布局：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">.left{</span></span>
<span class="line"><span style="color:#e1e4e8;">     width: 100px;</span></span>
<span class="line"><span style="color:#e1e4e8;">     height: 200px;</span></span>
<span class="line"><span style="color:#e1e4e8;">     background: red;</span></span>
<span class="line"><span style="color:#e1e4e8;">     float: left;</span></span>
<span class="line"><span style="color:#e1e4e8;"> }</span></span>
<span class="line"><span style="color:#e1e4e8;"> .right{</span></span>
<span class="line"><span style="color:#e1e4e8;">     height: 300px;</span></span>
<span class="line"><span style="color:#e1e4e8;">     background: blue;</span></span>
<span class="line"><span style="color:#e1e4e8;">     overflow: hidden;</span></span>
<span class="line"><span style="color:#e1e4e8;"> }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">.left{</span></span>
<span class="line"><span style="color:#24292e;">     width: 100px;</span></span>
<span class="line"><span style="color:#24292e;">     height: 200px;</span></span>
<span class="line"><span style="color:#24292e;">     background: red;</span></span>
<span class="line"><span style="color:#24292e;">     float: left;</span></span>
<span class="line"><span style="color:#24292e;"> }</span></span>
<span class="line"><span style="color:#24292e;"> .right{</span></span>
<span class="line"><span style="color:#24292e;">     height: 300px;</span></span>
<span class="line"><span style="color:#24292e;">     background: blue;</span></span>
<span class="line"><span style="color:#24292e;">     overflow: hidden;</span></span>
<span class="line"><span style="color:#24292e;"> }</span></span></code></pre></div><p>左侧设置float:left，右侧设置overflow: hidden。这样右边就触发了 BFC，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p><h2 id="什么是-margin-重叠问题-如何解决" tabindex="-1">什么是 margin 重叠问题？如何解决？ <a class="header-anchor" href="#什么是-margin-重叠问题-如何解决" aria-label="Permalink to &quot;什么是 margin 重叠问题？如何解决？&quot;">​</a></h2><p>问题描述：</p><p>两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。</p><p>计算原则：</p><p>折叠合并后外边距的计算原则如下：</p><ul><li>如果两者都是正数，取大者</li><li>如果是一正一负，取正值减去负值的绝对值</li><li>两个都是负值时，取绝对值大者</li></ul><p>解决办法：<br></p><p>对于折叠的情况，主要有两种：<code>兄弟之间重叠</code>和<code>父子之间重叠</code></p><ol><li>兄弟之间重叠</li></ol><ul><li>底部元素变为行内盒子：display: inline-block</li><li>底部元素设置浮动：float</li><li>底部元素的 position 的值为absolute/fixed</li></ul><ol start="2"><li>父子之间重叠</li></ol><ul><li>父元素加入：overflow: hidden</li><li>父元素添加透明边框：border:1px solid transparent</li><li>子元素变为行内盒子：display: inline-block</li><li>子元素加入浮动属性或定位</li></ul><h2 id="元素的层叠顺序" tabindex="-1">元素的层叠顺序 <a class="header-anchor" href="#元素的层叠顺序" aria-label="Permalink to &quot;元素的层叠顺序&quot;">​</a></h2><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p><p><img src="`+s+'" alt="H5 图片"></p><p>对于上图，由上到下分别是：</p><ol><li>背景和边框：建立当前层叠上下文元素的背景和边框。</li><li>负的 z-index：当前层叠上下文中，z-index 属性值为负的元素。</li><li>块级盒：文档流内非行内级非定位后代元素。</li><li>浮动盒：非定位浮动元素。</li><li>行内盒：文档流内行内级非定位后代元素。</li><li>z-index:0：层叠级数为 0 的定位元素。</li><li>正 z-index：z-index 属性值为正的定位元素。</li></ol><div class="tip custom-block"><p class="custom-block-title">提示</p><p>当定位元素 z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p></div><h2 id="position-的属性有哪些-区别是什么" tabindex="-1">position 的属性有哪些，区别是什么 <a class="header-anchor" href="#position-的属性有哪些-区别是什么" aria-label="Permalink to &quot;position 的属性有哪些，区别是什么&quot;">​</a></h2><table><thead><tr><th style="text-align:center;">position</th><th style="text-align:center;">有以下属性值：</th><th style="text-align:center;"></th></tr></thead><tbody><tr><td style="text-align:center;">属性值</td><td style="text-align:center;">概述</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">absolute</td><td style="text-align:center;">生成绝对定位的元素，相对于 static 定位以外的一个父元素进行定位。元素的位置通过 left、top、right、bottom 属性进行规定。</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">relative</td><td style="text-align:center;">生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过 left、top、right、bottom 属性进行规定。</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">fixed</td><td style="text-align:center;">生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定</td><td style="text-align:center;">位⽅式。</td></tr><tr><td style="text-align:center;">static</td><td style="text-align:center;">默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左</td><td style="text-align:center;">向右排列。</td></tr><tr><td style="text-align:center;">inherit</td><td style="text-align:center;">规定从父元素继承 position 属性的值</td><td style="text-align:center;"></td></tr></tbody></table><p>前面三者的定位方式如下：</p><p>relative： 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</p><p>fixed： 元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</p><p>absolute： 元素的定位相对于前两者要复杂许多。如果为 <code>absolute</code>设置了 <code>top</code>、<code>left</code>，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。</p><h2 id="display、float、position-的关系" tabindex="-1">display、float、position 的关系 <a class="header-anchor" href="#display、float、position-的关系" aria-label="Permalink to &quot;display、float、position 的关系&quot;">​</a></h2><ol><li>首先判断 display 属性是否为 none，如果为 none，则 position 和 float 属性的值不影响元素最后的表现。</li><li>然后判断 position 的值是否为 absolute 或者 fixed，如果是，则 float 属性失效，并且 display 的值应该被设置为 table 或者 block，具体转换需要看初始转换值。</li><li>如果 position 的值不为 absolute 或者 fixed，则判断 float 属性的值是否为 none，如果不是，则 display 的值则按上面的规则转换。注意，如果 position 的值为 relative 并且 float 属性的值存在，则 relative 相对于浮动后的最终位置定位。</li><li>如果 float 的值为 none，则判断元素是否为根元素，如果是根元素则 display 属性按照上面的规则转换，如果不是，则保持指定的 display 属性值不变。</li></ol><p>总的来说，可以把它看作是一个类似优先级的机制，<code>position:absolute</code> 和 <code>position:fixed</code>优先级最高，有它存在的时候，浮动不起作用，<code>display</code>的值也需要调整；其次，元素的 <code>float</code> 特性的值不是 <code>none</code> 的时候或者它是根元素的时候，调整 <code>display</code> 的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，<code>display</code> 特性值同设置值。</p><h2 id="absolute-与-fixed-共同点与不同点" tabindex="-1">absolute 与 fixed 共同点与不同点 <a class="header-anchor" href="#absolute-与-fixed-共同点与不同点" aria-label="Permalink to &quot;absolute 与 fixed 共同点与不同点&quot;">​</a></h2><p>共同点：</p><ul><li>改变行内元素的呈现方式，将 display 置为 <code>inline-block</code></li><li>使元素<code>脱离</code>普通文档流，不再占据文档物理空间</li><li>覆盖<code>非定位</code>文档元素</li></ul><p>不同点：</p><ul><li><code>absolute</code> 与 <code>fixed</code> 的根元素不同，<code>absolute</code> 的根元素可以设置，<code>fixed</code> 根元素是浏览器。</li><li>在有滚动条的页面中，<code>absolute</code> 会跟着父元素进行移动，<code>fixed</code> 固定在页面的具体位置。</li></ul><h2 id="对-sticky-定位的理解" tabindex="-1">对 sticky 定位的理解 <a class="header-anchor" href="#对-sticky-定位的理解" aria-label="Permalink to &quot;对 sticky 定位的理解&quot;">​</a></h2><p><code>sticky</code> 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的<code>滚动位置</code>来定位。</p><p>粘性定位的元素是依赖于用户的滚动，在 <code>position:relative</code> 与 <code>position:fixed</code> 定位之间切换。它的行为就像 <code>position:relative</code>; 而当页面滚动超出目标区域时，它的表现就像 <code>position:fixed</code>;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>',153),c=[n];function d(p,r,h,b,u,y){return t(),l("div",null,c)}const g=e(i,[["render",d]]);export{m as __pageData,g as default};
